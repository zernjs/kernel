#!/usr/bin/env node
/**
 * Lightweight generator for Zern typed augmentations.
 * Scans for exported descriptors named `ev` (events) and `ui` (alerts)
 * in *.plugin.ts files and emits declare-module augmentations
 * so zero-arg useEvents()/useAlerts() and ctx.kernel.* get autocomplete.
 */
import { promises as fs } from 'node:fs';
import { resolve } from 'node:path';
import chokidar from 'chokidar';

type Found = { file: string; hasEv: boolean; hasUi: boolean };

async function findPlugins(root: string): Promise<Found[]> {
  const dir = await fs.readdir(root, { withFileTypes: true });
  const results: Found[] = [];
  for (const de of dir) {
    if (de.name.startsWith('.')) continue;
    const full = resolve(root, de.name);
    if (de.isDirectory()) {
      results.push(...(await findPlugins(full)));
    } else if (de.isFile() && /\.plugin\.ts$/.test(de.name)) {
      const content = await fs.readFile(full, 'utf8');
      const hasEv = /export\s+const\s+ev\s*=\s*events\.createEvents\(/.test(content);
      const hasUi = /export\s+const\s+ui\s*=\s*alerts\.createAlerts\(/.test(content);
      if (hasEv || hasUi) results.push({ file: full, hasEv, hasUi });
    }
  }
  return results;
}

function toImportPath(abs: string): string {
  // produce a relative path from project root to the plugin file
  const rel = abs.replace(process.cwd() + resolve('/'), '').replace(/\\/g, '/');
  return `../${rel}`;
}

function generateDts(found: Found[]): string {
  const evDecls: string[] = [];
  const uiDecls: string[] = [];
  for (const f of found) {
    const importPath = toImportPath(f.file);
    if (f.hasEv) evDecls.push(`auth: typeof import('${importPath}').ev.spec; // adjust namespace`);
    if (f.hasUi) uiDecls.push(`ui: typeof import('${importPath}').ui.spec; // adjust namespace`);
  }
  const evBlock = evDecls.length
    ? `declare module '../src/events/types' { interface ZernEvents {\n${evDecls
        .map(s => `    ${s}`)
        .join('\n')}\n} }`
    : '';
  const uiBlock = uiDecls.length
    ? `declare module '../src/alerts/types' { interface ZernAlerts {\n${uiDecls
        .map(s => `    ${s}`)
        .join('\n')}\n} }`
    : '';
  const header = `/**
* AUTO-GENERATED FILE. Do not edit manually.
* Generated by tools/gen-types.mts
*/`;
  return [header, evBlock, uiBlock].filter(Boolean).join('\n\n');
}

async function runOnce(root: string): Promise<void> {
  const out = resolve('generated/zern-augmentations.d.ts');
  await fs.mkdir(resolve('generated'), { recursive: true });
  const found = await findPlugins(resolve(root));
  const content = generateDts(found);
  await fs.writeFile(out, content, 'utf8');
  const distTypesEntry = resolve('src/types/augment-imports.d.ts');
  const shim = `// side-effect imports for generated augmentations\n/// <reference path="../../generated/zern-augmentations.d.ts" />\n`;
  try {
    await fs.access(distTypesEntry);
  } catch {
    await fs.writeFile(distTypesEntry, shim, 'utf8');
  }
}

async function main(): Promise<void> {
  const root = process.argv.includes('--root')
    ? process.argv[process.argv.indexOf('--root') + 1]
    : 'examples';
  const watch = process.argv.includes('--watch');
  await runOnce(root);
  if (watch) {
    const watcher = chokidar.watch([`${root}/**/*.plugin.ts`], { ignoreInitial: true });
    watcher.on('all', async () => {
      await runOnce(root);
    });
  }
}

main().catch(err => {
  console.error('[gen-types] failed:', err);
  process.exit(1);
});
